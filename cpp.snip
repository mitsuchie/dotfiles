#--------------------------------------------------------------------
# template
#--------------------------------------------------------------------
snippet     template_library
abbr        "競技プログラミング用のテンプレート"
options     head
    #include <iostream>
    #include <vector>
    #include <list>
    #include <set>
    #include <map>
    #include <algorithm>
    #include <string>
    #include <complex>
    #include <cstdio>
    using namespace std;

    #define REP(i,p,n) for(int i=p;i<n;++i)
    #define rep(i,n) REP(i,0,n)

    typedef long long int ll;
    typedef pair<int,int> pii;
    typedef complex<double> point;

    int main()
    {
        ${0:code}
    }

snippet     gcd
abbr        "__gcd (gcc extend)"
options     head
    __gcd(${1},${2})${0}

#--------------------------------------------------------------------
# algorithms
#--------------------------------------------------------------------
snippet     dijkstra2
abbr        拡張ダイクストラ法
alias       dk2
options     head
    const int MAXN=64;   // 頂点数
    const int MAXC=1024; // 拡張数
    const ll INF=1<<30;  // 最大数
    ll dist[MAXN][MAXC]; // 距離
    vector<pii> G[MAXN]; // グラフ

    ll dijkstra2(int s,int t,int c)
    {
        rep(i,MAXN){ rep(j,MAXC){ dist[i][j]=INF; } }
        dist[s][c]=0;

        priority_queue< pii > Q;
        Q.push(make_pair(c,s)); // 拡張数を最大にする(逆なら符号反転)

        while(!Q.empty())
        {
            pii element = Q.top(); Q.pop();
            const int cc = element.first;
            const int pp = element.second;

            rep(i,G[pp].size())
            {
                // 通常時
                {
                    const int tt = G[pp][i].first;
                    const ll  ww = dist[pp][cc]+ll(G[pp][i].second);
                    if(ww<dist[tt][cc]){ dist[tt][cc]=ww; Q.push(pii(cc,tt)); }
                }

                if(cc>0) // 拡張時
                {
                    const int tt = G[pp][i].first;
                    const ll  ww = dist[pp][cc]-ll(G[pp][i].second);
                    if(ww<dist[tt][cc-1]){ dist[tt][cc-1]=ww; Q.push(pii(cc-1,tt)); }
                }
            }
        }

        ll res=INF;
        rep(i,c+1){ res=min(res,dist[t][i]); } // 拡張された中で最小を抽出
        return res;
    }
    
snippet     dijkstra
abbr        ダイクストラ法
alias       dk1
options     head
    const int MAXN=64;  // 頂点数
    const ll INF=1<<30; // 最大数
    ll dist[MAXN];      // 距離
    vector<pii> G[MAXN]; // グラフ
    struct GI { bool operator()(int a,int b){ return dist[a]<dist[b]; } }; // smaller

    ll dijkstra(int s,int t)
    {
        rep(i,MAXN){ dist[i]=INF; }
        dist[s] = 0;

        priority_queue<int,vector<int>,GI> Q;
        Q.push(s);

        while(!Q.empty())
        {
            const int ss = Q.top(); Q.pop();

            rep(i,G[ss].size())
            {
                const int tt = G[ss][i].first;
                const ll  ww = dist[ss]+ll(G[ss][i].second);
                if(ww<dist[tt]){ dist[tt]=ww; Q.push(tt); }
            }
        }
        return dist[t];
    }

snippet     pow
abbr        "繰り返し二乗方"
options     head
    ll pow(ll x,ll n)
    {
        if(n==0){ return 1; }
        if(n==1){ return x; }
        ll xx = pow(x,n/2);
        return (xx*xx)*(n&1?x:1);
    }${0}

snippet     ncr
abbr        "組み合わせの数"
options     head
    ll ncr(ll n,ll r)
    {
        ll x=1, y=1;
        for(ll i=n-r+1;i<=n;++i){ x*=i; }
        for(ll i=1;    i<=r;++i){ y*=i; }
        return (x/y);
    }${0}

snippet     ncr_with_mod
abbr        "組み合わせの数 フェルマーの小定理"
options     head
    ll ncr(ll n,ll r)
    {
        ll x=1, y=1;
        for(ll i=n-r+1;i<=n;++i){ x*=i; x%=mod; }
        for(ll i=1;    i<=r;++i){ y*=i; y%=mod; }
        y = pow(y,mod-2);
        return ((x%mod)*y)%mod;
    }${0}

snippet     msb
abbr        "最上位ビット"
options     head
    u32 msb(u32 x)
    {
        u32 lhs=0, rhs=32, mid=0;
        while(lhs+1<rhs){ mid=(lhs+rhs)>>1; (x>>mid?lhs:rhs)=mid; }
        return lhs;
    }

snippet     doubling
abbr        "ダブリング"
options     head
    // int fs[MAXM][MAXN]; // # => f0...fM (f:v->v の写像)

	rep(i,MAXM-1) rep(j,N)
	{
		fs[i+1][j] = fs[i][j]==-1 ? -1 : fs[i][fs[i][j]];
	}

snippet     lca
abbr        "最近共通先祖"
options     head
    // int fs[MAXM][MAXN]; // # => f0...fM (f:v->v の写像)

    int lca(int a,int b,int depth_a,int depth_b)
    {
        // 深さを揃える
        if(depth_a!=depth_b)
        {
            const bool ab = depth_a < depth_b;
            int len = ab ? depth_b-depth_a : depth_a-depth_b;
            int c   = ab ? b : a;
            rep(i,MAXM){ if((len>>i)&1){ c = fs[i][c]; } }
            a = ab ? a : c;
            b = ab ? c : b;
        }
        if( a == b ){ return a; }

        // 二分探索
        for(int i=MAXM-1;i>=0;--i) if(fs[i][a]!=fs[i][b])
        {
            a = fs[i][a];
            b = fs[i][b];
        }
        return fs[0][a];
    }

#--------------------------------------------------------------------
# cpp utils
#--------------------------------------------------------------------
snippet     line
abbr        "commentout line"
options     head
    //-------------------------------------------------------------------

#--------------------------------------------------------------------
snippet     singleton
abbr        "singleton"
options     head
    public:
    static ${1:classname}* instance();
    static void createInstance();
    static void destroyInstance();

    namespace { $1* p$1Instance; };
    $1* $1::instance()
    {
        assert(p$1Instance!=nullptr);
        return p$1Instance;
    }
    void $1::createInstance()
    {
        assert(p$1Instance==nullptr);
        p$1Instance = new $1();
    }
    void $1::destroyInstance()
    {
        assert(p$1Instance!=nullptr);
        delete p$1Instance;
        p$1Instance = 0;
    }
    inline $1& ${2:cliped}(){ return *$1::instance(); }


#--------------------------------------------------------------------
snippet     namespace
abbr        "namespace"
options     head
    namespace ${1:name}
    {
        ${0:code}
    };

#--------------------------------------------------------------------
snippet     class
abbr        "class"
options     head
    //===================================================================
    //
    // Class: $1
    // Author: mitsuchie
    //
    //===================================================================
    class ${1:name}
    {
    public:
        explicit $1();
        virtual ~$1();

        ${0:code}
    };
    $1::$1(){}
    $1::~$1(){}

#--------------------------------------------------------------------
snippet     class_devired
abbr        "class inherited others"
options     head
    //===================================================================
    //
    // Class: $1
    // Author: mitsuchie
    //
    //===================================================================
    class ${1:name}
    {
    public:
        explicit $1();
        virtual ~$1();

        ${0:code}
    };
    $1::$1(){}
    $1::~$1(){}

