#-------------------------------------------------------------------------------
# template
#-------------------------------------------------------------------------------
snippet     template_library
abbr        "競技プログラミング用のテンプレート"
options     head
    #include <iostream>
    #include <vector>
    #include <list>
    #include <set>
    #include <queue>
    #include <map>
    #include <algorithm>
    #include <functional>
    #include <string>
    #include <complex>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    using namespace std;

    #define REP(i,p,n) for(int i=p;i<n;++i)
    #define rep(i,n) REP(i,0,n)

    typedef long long int ll;
    typedef complex<double> point;
    typedef vector<int> vint;
    typedef vector<pii> vpii;
    typedef pair<int,int> pii;
    typedef vector<vint> det1;
    typedef vector<vpii> det2;

    int main()
    {
        ${0:code}

        return 0;
    }

#-------------------------------------------------------------------------------
# structure
#-------------------------------------------------------------------------------
snippet     edge
abbr        "グラフの辺の構造体"
alias       Edge
options     head
    struct Edge
    {
        int from, to, cost;

        Edge(){}
        Edge(int _from,int _to,int _cost):from(_from), to(_to), cost(_cost){}
        void input(int d=0){ cin>>from>>to>>cost; from-=d; to-=d; }
        void set(int _from,int _to,int _cost){ from=_from; to=_to; cost=_cost; }

        const bool operator<(const Edge& e) const { return cost<e.cost; }
    };

snippet     UnionFind
abbr        "Union-Find(グループ管理)"
alias       unionfind
alias       union-find
options     head
    struct UnionFind
    {
        vector<int> uf;
        // 親なし(-1)で初期化しておく
        void init(int n){ uf.assign(n,-1); }
        // 親がいないなら自分を返す, 親がいたら経路圧縮して返す(root直下に繋ぐ)
        int find(int x){ return uf[x]<0 ? x : (uf[x]=this->find(uf[x])); }
        // 繋げようとする(union/予約後なんですよね,これが)
        bool connect(int a,int b)
        {
            a = this->find(a); // aのルートノード
            b = this->find(b); // bのルートノード
            if(a!=b){ uf[b]=a; return true; } // 新しくつなげた
            return false; // もうつながってる
        }

    } uf;

#-------------------------------------------------------------------------------
# algorithm
#-------------------------------------------------------------------------------
snippet     gcd
abbr        "__gcd (gcc extend)"
options     head
    __gcd(${1},${2})${0}

snippet     dijkstra2
abbr        "拡張ダイクストラ法"
alias       dk2
options     head
    const int MAXN=64;   // 頂点数
    const int MAXC=1024; // 拡張数
    const ll INF=1<<30;  // 最大数
    ll dist[MAXN][MAXC]; // 距離
    vector<pii> G[MAXN]; // グラフ

    ll dijkstra2(int s,int t,int c)
    {
        rep(i,MAXN){ rep(j,MAXC){ dist[i][j]=INF; } }
        dist[s][c]=0;

        priority_queue< pii > Q;
        Q.push(make_pair(c,s)); // 拡張数を最大にする(逆なら符号反転)

        while(!Q.empty())
        {
            pii element = Q.top(); Q.pop();
            const int cc = element.first;
            const int pp = element.second;

            rep(i,G[pp].size())
            {
                // 通常時
                {
                    const int tt = G[pp][i].first;
                    const ll  ww = dist[pp][cc]+ll(G[pp][i].second);
                    if(ww<dist[tt][cc]){ dist[tt][cc]=ww; Q.push(pii(cc,tt)); }
                }

                if(cc>0) // 拡張時
                {
                    const int tt = G[pp][i].first;
                    const ll  ww = dist[pp][cc]-ll(G[pp][i].second);
                    if(ww<dist[tt][cc-1]){ dist[tt][cc-1]=ww; Q.push(pii(cc-1,tt)); }
                }
            }
        }

        ll res=INF;
        rep(i,c+1){ res=min(res,dist[t][i]); } // 拡張された中で最小を抽出
        return res;
    }
    
snippet     dijkstra
abbr        "ダイクストラ法"
alias       dk1
options     head
    const int MAXN=64;  // 頂点数
    const ll INF=1<<30; // 最大数
    ll dist[MAXN];      // 距離
    vector<pii> G[MAXN]; // グラフ
    struct GI { bool operator()(int a,int b){ return dist[a]<dist[b]; } }; // smaller

    ll dijkstra(int s,int t)
    {
        rep(i,MAXN){ dist[i]=INF; }
        dist[s] = 0;

        priority_queue<int,vector<int>,GI> Q;
        Q.push(s);

        while(!Q.empty())
        {
            const int ss = Q.top(); Q.pop();

            rep(i,G[ss].size())
            {
                const int tt = G[ss][i].first;
                const ll  ww = dist[ss]+ll(G[ss][i].second);
                if(ww<dist[tt]){ dist[tt]=ww; Q.push(tt); }
            }
        }
        return dist[t];
    }

snippet     pow
abbr        "繰り返し二乗方"
options     head
    ll pow(ll x,ll n)
    {
        if(n==0){ return 1; }
        if(n==1){ return x; }
        ll xx = pow(x,n/2);
        return (xx*xx)*(n&1?x:1);
    }${0}

snippet     ncr
abbr        "組み合わせの数"
options     head
    ll ncr(ll n,ll r)
    {
        ll x=1, y=1;
        for(ll i=n-r+1;i<=n;++i){ x*=i; }
        for(ll i=1;    i<=r;++i){ y*=i; }
        return (x/y);
    }${0}

snippet     ncr_with_mod
abbr        "組み合わせの数 フェルマーの小定理"
options     head
    ll ncr(ll n,ll r)
    {
        ll x=1, y=1;
        for(ll i=n-r+1;i<=n;++i){ x*=i; x%=mod; }
        for(ll i=1;    i<=r;++i){ y*=i; y%=mod; }
        y = pow(y,mod-2);
        return ((x%mod)*y)%mod;
    }${0}

snippet     msb
abbr        "最上位ビット"
options     head
    u32 msb(u32 x)
    {
        u32 lhs=0, rhs=32, mid=0;
        while(lhs+1<rhs){ mid=(lhs+rhs)>>1; (x>>mid?lhs:rhs)=mid; }
        return lhs;
    }

snippet     doubling
abbr        "ダブリング"
options     head
    // int fs[MAXM][MAXN]; // # => f0...fM (f:v->v の写像)

	rep(i,MAXM-1) rep(j,N)
	{
		fs[i+1][j] = fs[i][j]==-1 ? -1 : fs[i][fs[i][j]];
	}

snippet     lca
abbr        "最近共通先祖"
options     head
    // int fs[MAXM][MAXN]; // # => f0...fM (f:v->v の写像)

    int lca(int a,int b,int depth_a,int depth_b)
    {
        // 深さを揃える
        if(depth_a!=depth_b)
        {
            const bool ab = depth_a < depth_b;
            int len = ab ? depth_b-depth_a : depth_a-depth_b;
            int c   = ab ? b : a;
            rep(i,MAXM){ if((len>>i)&1){ c = fs[i][c]; } }
            a = ab ? a : c;
            b = ab ? c : b;
        }
        if( a == b ){ return a; }

        // ダブリング
        for(int i=MAXM-1;i>=0;--i) if(fs[i][a]!=fs[i][b])
        {
            a = fs[i][a];
            b = fs[i][b];
        }
        return fs[0][a];
    }

snippet     kruscal
abbr        クラスカル法
alias       minimum-spanning-tree
options     head
    ll kruscal(int n,vector<Edge>& edges) // need (unionfind, edge)
    {
        ll res = 0;

        sort(edges.begin(), edges.end());
        uf.init(n);

        rep(i,edges.size()) // 各辺に注目する(コストの小さい順)
        {
            if(uf.connect(edges[i].from, edges[i].to))
            {
                res+=edges[i].cost; // 連結成分でなければ辺を結ぶ
            }
        }

        return res;
    }

snippet     prim
abbr        "プリム法"
options     head
    ll prim(det2& det) // need (edge)
    {
        int left = det.size()-1;

        vector<int> v(det.size(),0);
        v[0] = 1; // 開始頂点

        // コストでソートされるキューを使う [cost,to]
        priority_queue<pii,vector<pii>,greater<pii> > Q;
        for(auto e:det[0]){ Q.push(e); }

        ll res = 0;
        while(!Q.empty() && left) // 全頂点に到達できるまで続ける
        {
            const int cost = Q.top().first;
            const int to   = Q.top().second;
            Q.pop();

            if(v[to]){ continue; } else { v[to]=1; --left; }
            res += cost;

            if(left==0){ break; }

            // 注目している頂点から出ている辺で回す(到達済みは除く)
            for(auto e:det[to]){ if(!v[e.second]){ Q.push(e); } }
        }

        return res;
    }

#-------------------------------------------------------------------------------
# cpp utils
#-------------------------------------------------------------------------------
snippet     line
abbr        "commentout line"
options     head
    //------------------------------------------------------------------------------

snippet     size
abbr        size() 括弧補完
options     head
    size()

snippet     sort
abbr        sort(x.begin(), x.end())
options     head
    sort(${1}.begin(), $1.end());${0}


#-------------------------------------------------------------------------------
snippet     singleton
abbr        "singleton"
options     head
    public:
    static ${1:classname}* instance();
    static void createInstance();
    static void destroyInstance();

    namespace { $1* p$1Instance; };
    $1* $1::instance()
    {
        assert(p$1Instance!=nullptr);
        return p$1Instance;
    }
    void $1::createInstance()
    {
        assert(p$1Instance==nullptr);
        p$1Instance = new $1();
    }
    void $1::destroyInstance()
    {
        assert(p$1Instance!=nullptr);
        delete p$1Instance;
        p$1Instance = 0;
    }
    inline $1& ${2:cliped}(){ return *$1::instance(); }


#-------------------------------------------------------------------------------
snippet     namespace
abbr        "namespace"
options     head
    namespace ${1:name}
    {
        ${0:code}
    };

#-------------------------------------------------------------------------------
snippet     class
abbr        "class"
options     head
    //==============================================================================
    //
    // Class: $1
    // Author: ${2:username}
    //
    //==============================================================================
    class ${1:name}
    {
    public:
        explicit $1();
        virtual ~$1();

        ${0:code}
    };
    $1::$1(){}
    $1::~$1(){}

#-------------------------------------------------------------------------------
snippet     class_devired
abbr        "class inherited others"
options     head
    //==============================================================================
    //
    // Class: $1
    // Author: ${2:username}
    //
    //==============================================================================
    class ${1:name}
    {
    public:
        explicit $1();
        virtual ~$1();

        ${0:code}
    };
    $1::$1(){}
    $1::~$1(){}

